"""Diagnose lensed C_l accuracy: TT, EE, TE, BB vs CLASS reference.

Uses CLASS reference unlensed C_l and C_l^pp as input to test the
lensing algorithm in isolation.
"""
import sys
import time

sys.path.insert(0, '.')

import jax
jax.config.update("jax_enable_x64", True)

import jax.numpy as jnp
import numpy as np

from jaxclass.lensing import lens_cls

# Load CLASS reference data
cls_unlensed = dict(np.load('reference_data/lcdm_fiducial/cls.npz'))
cls_lensed_ref = dict(np.load('reference_data/lcdm_fiducial/cls_lensed.npz'))

cl_tt = jnp.array(cls_unlensed['tt'])
cl_ee = jnp.array(cls_unlensed['ee'])
cl_te = jnp.array(cls_unlensed['te'])
cl_bb = jnp.array(cls_unlensed['bb'])
cl_pp = jnp.array(cls_unlensed['pp'])

l_max = 2500

print("Computing lensed C_l (first call includes JIT compilation)...")
t0 = time.time()
tt_lens, ee_lens, te_lens, bb_lens = lens_cls(
    cl_tt, cl_ee, cl_te, cl_bb, cl_pp, l_max=l_max, n_gauss=4096
)
# Force computation
tt_lens = np.array(tt_lens)
ee_lens = np.array(ee_lens)
te_lens = np.array(te_lens)
bb_lens = np.array(bb_lens)
dt = time.time() - t0
print(f"Done in {dt:.1f}s (includes JIT)\n")

# Compare against CLASS lensed reference
tt_ref = np.array(cls_lensed_ref['tt'])
ee_ref = np.array(cls_lensed_ref['ee'])
te_ref = np.array(cls_lensed_ref['te'])
bb_ref = np.array(cls_lensed_ref['bb'])

test_ells = [10, 30, 50, 100, 200, 500, 1000, 1500, 2000, 2500]

print("=" * 80)
print(f"{'l':>6}  {'TT err%':>10}  {'EE err%':>10}  {'TE err%':>10}  {'BB us':>12}  {'BB ref':>12}")
print("=" * 80)

for l in test_ells:
    if l > l_max:
        continue

    tt_err = (tt_lens[l] - tt_ref[l]) / abs(tt_ref[l]) * 100 if abs(tt_ref[l]) > 1e-30 else 0.0
    ee_err = (ee_lens[l] - ee_ref[l]) / abs(ee_ref[l]) * 100 if abs(ee_ref[l]) > 1e-30 else 0.0

    # TE can be near zero, use absolute error
    if abs(te_ref[l]) > 1e-30:
        te_err = (te_lens[l] - te_ref[l]) / abs(te_ref[l]) * 100
    else:
        te_err = 0.0

    print(f"{l:6d}  {tt_err:+10.3f}  {ee_err:+10.3f}  {te_err:+10.3f}  {bb_lens[l]:12.4e}  {bb_ref[l]:12.4e}")

# Dense l sampling for TT
print("\n--- Dense TT lensing accuracy ---")
print(f"{'l':>6}  {'TT err%':>10}  {'EE err%':>10}")
for l in range(10, 2510, 100):
    if l > l_max:
        break
    if abs(tt_ref[l]) > 1e-30:
        tt_err = (tt_lens[l] - tt_ref[l]) / abs(tt_ref[l]) * 100
    else:
        tt_err = 0.0
    if abs(ee_ref[l]) > 1e-30:
        ee_err = (ee_lens[l] - ee_ref[l]) / abs(ee_ref[l]) * 100
    else:
        ee_err = 0.0
    print(f"{l:6d}  {tt_err:+10.4f}  {ee_err:+10.4f}")

# Summary statistics
print("\n--- Summary ---")
for name, us, ref in [("TT", tt_lens, tt_ref), ("EE", ee_lens, ee_ref)]:
    errs = []
    for l in range(10, 2001):
        if abs(ref[l]) > 1e-30:
            errs.append(abs((us[l] - ref[l]) / ref[l]) * 100)
    errs = np.array(errs)
    print(f"{name}: max err = {errs.max():.3f}%, mean err = {errs.mean():.3f}%, "
          f"sub-1% at {(errs < 1.0).sum()}/{len(errs)} l-values")

# BB lensing: ratio test (BB is generated by lensing from E-modes)
print("\n--- BB lensing (generated from E-modes) ---")
for l in [10, 50, 100, 200, 500, 1000]:
    if abs(bb_ref[l]) > 1e-30:
        ratio = bb_lens[l] / bb_ref[l]
        print(f"l={l:4d}: BB ratio = {ratio:.4f}")
    else:
        print(f"l={l:4d}: BB ref is zero")

# Second call timing (JIT cached)
print("\nTiming (JIT cached)...")
t0 = time.time()
tt2, ee2, te2, bb2 = lens_cls(
    cl_tt, cl_ee, cl_te, cl_bb, cl_pp, l_max=l_max, n_gauss=4096
)
np.array(tt2)  # force
dt = time.time() - t0
print(f"Second call: {dt:.2f}s")
